"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.McuLogger = void 0;
const winston_1 = require("winston");
const _ = __importStar(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const stackLevel_1 = __importDefault(require("./lib/stackLevel"));
const transports_1 = require("./lib/transports");
const splat_1 = require("./lib/splat");
const queue_1 = require("./lib/queue");
const circularReplacer_1 = __importDefault(require("./lib/circularReplacer"));
class McuLogger {
    constructor(config) {
        this.container_name = process.env.SERVICE_NAME || '';
        this.container_id = process.env.HOSTNAME || '';
        this.default_filename = `${this.container_name}-${this.container_id}.log`;
        this.init(config);
        const McuLogger = this;
        return new Proxy(this, {
            get(target, name) {
                const logger = McuLogger.logger;
                if (name === "update") {
                    return function () { McuLogger.update(...arguments); };
                }
                const methods = ['info', 'debug', 'warn', 'error', 'verbose'];
                if (logger && logger[name] && typeof logger[name] === 'function') {
                    return function () {
                        const loggerMethod = McuLogger.loggerMethod;
                        if (methods.includes(name) && loggerMethod === 'queue') {
                            const stack = stackLevel_1.default.get(loggerMethod);
                            const timestamp = moment_1.default().format('YYYY-MM-DD hh:mm:ss:SSS');
                            queue_1.betterQueue.queue.push({ args: arguments, stack: { stack }, timestamp, level: name, loggerMethod });
                        }
                        else if (logger[name]) {
                            logger[name](...arguments, { loggerMethod });
                        }
                    };
                }
                else {
                    if (logger[name]) {
                        return logger[name];
                    }
                    if (McuLogger[name]) {
                        return McuLogger[name];
                    }
                }
            },
            set(target, name, value) {
                const logger = McuLogger.logger;
                if (logger[name]) {
                    logger[name] = value;
                }
                return true;
            }
        });
    }
    end() {
        throw new Error('Method not implemented.');
    }
    on(arg0, arg1) {
        throw new Error('Method not implemented.');
    }
    defaults() {
        const defaults = {
            level: "info",
            loggerMethod: 'config',
            loggerType: 'print',
            stackLevel: 13,
            nat: {
                enabled: false,
                servers: ['nats://127.0.0.1:6060']
            },
            file: {
                enabled: false,
                filename: this.default_filename,
                rotate: {
                    enabled: false,
                    filename: `${this.container_name}-${this.container_id}-%DATE%.log`,
                    datePattern: 'YYYY-MM-DD-HH',
                    zippedArchive: true,
                    maxSize: '20m',
                    maxFiles: '14d'
                }
            }
        };
        return defaults;
    }
    update(config) {
        config = _.merge(this.config, config);
        this.init(config);
    }
    init(config) {
        const defaults = this.defaults();
        this.config = _.merge(defaults, config);
        this.loggerMethod = process.env.LOGGER_METHOD || this.config.loggerMethod;
        this.loggerType = process.env.LOGGER_TYPE || this.config.loggerType;
        stackLevel_1.default.set(this.config.stackLevel);
        const levels = { error: 0, warn: 1, info: 2, verbose: 3, debug: 4 };
        const { combine, timestamp } = winston_1.format;
        const transports = transports_1.winstonTransports(this.config, this.container_id, this.container_name);
        const logger = {
            level: this.config.level,
            levels,
            format: combine(timestamp(), splat_1.splat(), winston_1.format.metadata({ fillExcept: ['message', 'level', 'timestamp', 'label'] }), winston_1.format.printf((log) => {
                const loggerType = process.env.LOGGER_TYPE || this.loggerType;
                const loggerMethod = process.env.LOGGER_METHOD || this.loggerMethod;
                let { level, message, timestamp, metadata } = log;
                if (typeof message === 'object') {
                    message = JSON.stringify(message, circularReplacer_1.default());
                    if (level === 'error') {
                        console.error(message);
                    }
                }
                let stack;
                if (loggerMethod === 'queue' && metadata.stack) {
                    stack = metadata.stack;
                    delete metadata.stack;
                }
                else {
                    delete metadata.loggerMethod;
                    stack = stackLevel_1.default.get(loggerMethod);
                }
                if (metadata.metadata)
                    metadata = metadata.metadata;
                if (typeof message == 'object') {
                    message = JSON.stringify(message);
                    message = _.merge(message, metadata);
                }
                else if (typeof message == 'string' && Object.keys(metadata).length !== 0) {
                    metadata.push(message);
                    message = JSON.stringify(metadata);
                }
                const stackReponse = (stack) ? `${stack.method} ${stack.filename} ${stack.line}` : '';
                const jsonmeta = (Object.keys(metadata).length !== 0) ? JSON.stringify(metadata) : '';
                if (loggerType === 'json') {
                    const resp = JSON.stringify({ timestamp, level, message, metadata: jsonmeta, stack: stackReponse });
                    return resp;
                }
                else {
                    return `${timestamp} ${level} ${message} ${stackReponse}`;
                }
            })),
            transports
        };
        this.logger = winston_1.createLogger(logger);
        this.queue = queue_1.betterQueue.create(this.logger);
    }
}
exports.McuLogger = McuLogger;
